<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>hswatchd</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">hswatchd</h1>
<p class="date">24.04.2024</p>
</header>
<h1 id="name">NAME</h1>
<p><strong>hswatchd</strong> - Ein Daemon zum Ueberwachen von
Dateien</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p>Daemonen werden ueber “systemd” gestartet. Dieser ueberwacht Dateien
auf Aenderung und fuehrt, wenn vorhanden, einen Befehl aus.</p>
<h1 id="description">DESCRIPTION</h1>
<div class="line-block">hswatchd ist ausgelegt auf kleinst moegliche
CPU-Performance. Er wird ueber den <em>systemd</em> gestartet. Wer
moechte kann sich gerne auch eine init-Loesung schreiben.<br />
Alle Parameter werden in der <strong><em>/etc/hswatchd.rc</em></strong>
eingetragen.</div>
<h1 id="options">OPTIONS</h1>
<p><strong>--version </strong> :die aktuelle Version ausgeben lassen.
Das Programm wird allerdings dann beendet.</p>
<p>Da hswatchd als Daemon gestartet wird, gibt es fuer den Betrieb keine
Optionen. Dafür wird eine hswatchd.rc erwartet.</p>
<h1 id="signals">SIGNALS</h1>
<dl>
<dt><strong>SIGHUP,SIGKILL,SIGINT</strong></dt>
<dd>
Der Daemon wird beendet
</dd>
<dt><strong>SIGUSR1</strong></dt>
<dd>
reload der hswatchd.rc
</dd>
<dt><strong>SIGUSR2</strong></dt>
<dd>
ausgabe der Infodatei
</dd>
</dl>
<h1 id="environment">ENVIRONMENT</h1>
<dl>
<dt>Starten, stopppen, service:</dt>
<dd>
siehe Anschnitt: <strong>SYSTEMD</strong>
</dd>
<dt>Konfiguration:</dt>
<dd>
siehe Anschnitt: <strong>hswatchd.rc</strong>
</dd>
</dl>
<h1 id="systemd">SYSTEMD</h1>
<p>Sicher gibt es viele Wege um einen Daemon zu laufen zu bekommen.
Derzeit wird aber SYSTEMD ueberall verwendet.</p>
<p>Achtung. Zum grossen Teil werden ROOT-Rechte noetig sein.</p>
<div class="line-block">Datei erstellen<br />
:/etc/systemd/system/hswatchd.service</div>
<div class="line-block">Inhalt:</div>
<pre class="hswatchd.service"><code>[Unit]
Description=hswatchd - demon watching files for changing
After=network.target

[Service]
ExecStart=/usr/sbin/hswatchd
ExecStop=/bin/kill -HUP $MAINPID
ExecReload=/bin/kill -USR1 $MAINPID

StandardOutput=null
#StandardOutput=/root/out.txt
#Restart=on-failure

[Install]
WantedBy=multi-user.target</code></pre>
<p>#EOF</p>
<div class="line-block">Service einrichten (einmalig, started danach
automatisch mit):</div>
<pre class="service"><code>systemctl daemon-reload
systemctl enable hswatchd.service
systemctl start hswatchd.service
systemctl status hswatchd</code></pre>
<h1 id="hswatchd.rc">hswatchd.rc</h1>
<div class="line-block"><strong>Parameter:</strong></div>
<dl>
<dt># Server Einstellungen</dt>
<dd>
Zeilen, die mit ‘#’ beginnen, sind Kommentare und werden entsprechend
ignoriert. Uebrigens auch Leerzeilen
</dd>
<dt>port = 8080</dt>
<dd>
Portangabe. hswatchd kann über http abgefragt werden
</dd>
<dd>
siehe Anschnitt: **HTTP*
</dd>
<dt>time = ###</dt>
<dd>
Defaultangabe zum verweilen zwischen einer Pruefeinheit. Ist nicht so
wichtig, da die Zeit automatisch errechnet wird.
</dd>
<dt>cache = <em>true</em> oder <em>false</em></dt>
<dd>
Die Benutzung des Caches erlauben/verbieten
</dd>
<dt>cachepath = <em>Pfad_zur_Cachedatei</em></dt>
<dd>
Der Pfad für eine chache-Datei. Es wird in dieser Datei die
sekundengenaue Zeit der letzten Pruefung jedes File gespeichert. Gefolgt
von dem Dateinamen.
</dd>
<dt>infoupdate = 3600</dt>
<dd>
In diesem Fall wird alle 3600 Sekunden ein Infofile erstellt.
</dd>
<dt>infofile = <em>File_fuer_InfoFile</em></dt>
<dd>
Der vollständige Pfad zur Datei. Es wird eine reine Textdatei
geschrieben. Ist Markdown formatierbar. Diese Angabe kann auch leer sein
(oder besser auskommentiert) werden.
</dd>
</dl>
<p>Jeder Eintrag mit “file ….” in der hswatchd.rc wird in eine einfach
verkettete Liste sortiert, nach naechster Bearbeitungszeit, aufgenommen.
Dadurch wird erreicht das der naechste zu verarbeitende Datensatz ganz
oben steht. Die Diff-Zeit wird auch genommen, um die naechste Wartezeit
zu setzen. Ist so ein Datensatz abgearbeitet, wird neu entschieden, wo
er in der Liste zu stehen hat. Und es wird eine neue Wartezeit bestimmt.
Diese Informationen koennen auch über http abgerufen werden !!</p>
<div class="line-block">Konfigurations-Datei erstellen<br />
:/etc/hswatchd.rc</div>
<h3 id="beispiel">Beispiel:</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode hswatchd.rc"><code class="sourceCode xml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a># systemweite hswatchd - Konfigurationsdatei</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>port        = 8080</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>time        = 1</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>cache       = true</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>cachepath   = /var/hswatchd/files.cache</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>infoupdate  = 3600</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>infofile    = /srv/pub/www/data/watch-debug-hesti.txt</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a># File - Section</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>file /pub/share/network/stuff.txt       25  /bin/bash /root/bin/doany.sh inplement stuff</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>file /pub/share/network/admin_hosts     60  cp /pub/share/network/newfile_hosts /etc/hosts</span></code></pre></div>
<h1 id="http-service">HTTP-Service</h1>
<p>hswatchd verfügt eine rudimentäre html-Schnittstelle. Hier lassen
sich ein paar Informationen abrufen. Der Port ist in der
<em>hswatchd.rc</em> zu definiert.</p>
<dl>
<dt><em>server:8080/reload.cgi</em></dt>
<dd>
wird hswatchd dazu veranlassen die hswatchd.rc neu zu laden.
</dd>
<dt><em>server:8080//date.cgi</em></dt>
<dd>
gibt das aktuelle datum mit der Zeit aus. Das war nur zum Testen drin,
aber es stoert ja auch niemanden.
</dd>
<dt><em>server:8080//nextwatch.html</em></dt>
<dd>
Eine ausfuerliche Seite, welche Dateien als naechstes geprueft werden
und eine kurze Uebersicht welche Parameter mit wirken.
</dd>
<dt><em>server:8080//drive.cgi?</em></dt>
<dd>
Gefolgt von dem Mount-Point gibt ein paar Informationen ueber gemountete
Laufwerke auf dem Server preis. Diese koennen so gezielt gesammelt
werden. Ein Aufruf wie <em>server:8080//drive.cgi?&amp;boot</em> wird
die RootPartition und die boot-Partition ausgeben.
</dd>
</dl>
<p>#EOF</p>
<h1 id="authors">AUTHORS</h1>
<p>Heiko Stoevesandt - alias Hesti - <a
href="mailto:hstools@t-online.de"
class="email">hstools@t-online.de</a></p>
<h1 id="fehler">FEHLER</h1>
<p>Fehler (auch in dieser Manpage) unbedingt bitte melden</p>
</body>
</html>
